---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wuxin.
--- DateTime: 2019-11-14 18:12
---
---
local ck = require "resty.cookie"
local Object = require "kong.vendor.classic"
local redismod = require "resty.redis"

local HttpMethod = Object:extend()

function HttpMethod:new()

end
function HttpMethod:getScopeValue() end
function HttpMethod:build(t,conf)
    kong.log.err("in HttpMethod build...",t.scope)
    -- 请求参数
    t = self:appendRequestParam(t)
    -- IP
    t = self:appendIP(t)

    -- 请求头
    t = self:appendHeader(t)

    -- 请求cookie
    t = self:appendCookie(t)

    -- 用户信息
    t = self:appendUser(t,conf)


    return t

end

-- 将header加入表中
function HttpMethod:appendHeader(t)
    for name, value in pairs(ngx.req.get_headers()) do
        t["header_"..name] = value
    end

    self.header = ngx.req.get_headers()
    return t
end

-- 将cookie加入表中
function HttpMethod:appendCookie(t)
    local cookie, err = ck:new()
    if err then
        kong.log.err( err)
        return t
    end

    -- get all cookies
    local fields, err = cookie:get_all()
    if err then
        kong.log.err( err)
        return t
    end

    for k, v in pairs(fields) do
        t["cookie_"..k] = v
    end

    self.cookie = ngx.var.http_cookie

    return t
end

-- 将IP加入表中
function HttpMethod:appendIP(t)
    local ip = ngx.req.get_headers()["X-Forwarded-For"]
    if not ip then
        ip = ngx.req.get_headers()["remote_addr"]
    end

    t["IP"] = ip

    return t
end

local function closeRedis(redis)
    redis:set_keepalive(2 * 60 * 1000, 10) -- 单位 ms
end

-- 从redis中拿用户信息放到请求参数中
function HttpMethod:appendUser(t,conf)
    local token = ngx.var["cookie_"..conf.cookiesName]
    if not token or token == "" then
        return
    end

    -- 连接redis
    local redis = redismod:new()
    redis:set_timeouts(conf.redisTimeout, conf.redisTimeout, conf.redisTimeout)

    local ok, err = redis:connect(conf.redisHost, conf.redisPort)
    if not ok then
        kong.log.err("failed to connect redis: ", err)
        return
    end


    local res, err = redis:get(conf.tokenPrefix .. token)

    if err or not res or res == ngx.null then
        closeRedis(redis)
        return
    end

    t["user"] = res
    return t
end





-- get 方法对应的实现
local GetMethod = HttpMethod:extend()

function GetMethod:new()
    self.method = ngx.HTTP_GET
end

function GetMethod:getScopeValue()

     local scope = ngx.req.get_uri_args()["scope"]
     return scope
end

function GetMethod:appendRequestParam(t)
    for name, value in pairs(ngx.req.get_uri_args()) do
        t[name] = value
    end

    return t
end






-- post方法对应的实现
local PostMethod = HttpMethod:extend()

function PostMethod:new()
    self.method = ngx.HTTP_POST
    ngx.req.read_body()

    local uri_args = kong.request.get_query()  -- url参数
    local body_args = kong.request.get_body()  -- 表单参数
    local ptalbe = kong.table.merge(uri_args, body_args)
    self.ptalbe = ptalbe
end

function PostMethod:getScopeValue()

    return self.ptalbe["scope"]
end

function PostMethod:appendRequestParam(t)
    for name, value in pairs(self.ptalbe) do
        t[name] = value
    end
    return t
end







local httpmod = require "resty.http"
local cjson = require "cjson.safe"

local kong = kong

local ejuoauthclient = {}
ejuoauthclient.VERSION = "1.0"
ejuoauthclient.PRIORITY=220


function ejuoauthclient:access(conf)

    -- 如果其它插件设置了这个标志，则表示无需再作任何处理
    if ngx.ctx.eju_dont_do_anything then
        return
    end


    -- 从请求参数中获取scope
    local method = ngx.req.get_method()

    local httpMethod
    if method == "GET" then
        httpMethod = GetMethod()
    elseif method == "POST" then
        httpMethod = PostMethod()
    else
        return
    end

    local scope = httpMethod:getScopeValue()
    if not scope then
        kong.log.err("没有找到scope")
        return
     end

    -- 将请求参数拼装成一个json，供授权服务器决定是否返回令牌
    local paramTable = {}
    paramTable.scope = scope
    httpMethod:build(paramTable,conf)

    -- paramTable.url = conf.tokenURL -- 子请求地址参数

    --for i, v in pairs(paramTable) do
    --    kong.log.err("****",i ," = " ,  v)
    --end

    -- 验证自己
    local base64 = ngx.encode_base64(conf.clientId .. conf.clientSecret)

    -- 如果授权服务器也走了该插件，则能过break跳过请求授权服务器，避免死循环
    if not paramTable["break"] then
        local http = httpmod:new()

        local res, err = http:request_uri(conf.tokenURL, {
            method = "POST",
            headers = {
                ["Content-Type"] = "application/x-www-form-urlencoded",
                ["Authorization"] = "Basic ".. base64,
                -- ["Accept"] = "application/json"
            },
             -- body = "scope=1&a=1&b=2",
            body = "&grant_type=client_credentials&authctx=" .. ngx.encode_base64(cjson.encode(paramTable)) .. "&scope=" .. scope  ,
            query = "break=1",

            keepalive_timeout = 60,
            keepalive_pool = 10
        })

        -- kong.log.err("<<<<<<<<",err)
        kong.log.err(">>>>>>>>",res.status, ">>>>", res.body)
        if not err and res.status == ngx.HTTP_OK  then
            -- 如果返回令牌，则将令牌放在 http头中，供下一步使用
            ngx.req.set_header("Authorization","Bearer " .. res.body)
            -- ngx.req.set_header("Authorization","Bearer abcdefg")
            kong.log.err(">>>>>>>>",res.body)
        end

        http:close()
    else
        kong.log.err(cjson.encode(paramTable))
    end






    -- 如果拒绝用户权限，则继续往下执行（请求会被后续插件拒绝掉）





end



return ejuoauthclient